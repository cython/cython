
PYTHON check_paths_from_cython.py

######## src/pkg/__init__.py ########

# __init__.py is needed because cython uses this to determine the
# root of the package structure.

######## src/pkg/mod.pyx ########

def func(x):
    return 2*x

######## build/src/pkg/empty_build_output_directory.txt ########

# Build outputs go in the "build/" directory and cython is run from there.

######## check_paths_from_cython.py ########

import sys
import subprocess

python = sys.executable

def cython(cmdstr, cwd=None):
    argv = [python, '-m', 'cython'] + cmdstr.split()
    subprocess.run(argv, check=True, cwd=cwd)

def grep_paths(fname, pattern):
    with open(fname) as fin:
        for line in fin:
            if pattern in line:
                [part] = [p for p in line.split() if pattern in p]
                yield part.rstrip(',\n;:01234566789').strip('"')

cython('-3 src/pkg/mod.pyx -o build/src/pkg/mod1.pyx.c')
cython('-3 ../src/pkg/mod.pyx -o src/pkg/mod2.pyx.c', cwd='build')

res1 = grep_paths('build/src/pkg/mod1.pyx.c', 'mod.pyx')
res2 = grep_paths('build/src/pkg/mod2.pyx.c', 'mod.pyx')

# Running cython on a file in CWD uses some paths relative to CWD.
assert set(res1) == {"src/pkg/mod.pyx", "pkg/mod.pyx"}, str(res1)

# When not in CWD all paths are relative to sys.path.
assert set(res2) == {"pkg/mod.pyx"}, str(res2)
