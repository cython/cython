# mode: run
# tag: embed

CYTHONIZE -j2 embedded1.pyx embedded2.pyx
CYTHON --embed --embed-modules embedded1,embedded2 main_module.pyx
PYTHON build.py main_module main_module.c embedded1.c embedded2.c
PYTHON run.py main_module

################### build.py ########################

import os
import setuptools
import sys
import sysconfig
from concurrent.futures import ThreadPoolExecutor

IS_WINDOWS = sys.platform == 'win32'

if IS_WINDOWS:
    import distutils.msvc9compiler as setuptools_msvc  # from setuptools
    ccompiler = setuptools_msvc.MSVCCompiler()
    ccompiler.initialize()
    compiler_exe = ccompiler.cc
    linker_exe = ccompiler.linker
else:
    import distutils.unixccompiler as setuptools_cc  # from setuptools
    ccompiler = setuptools_cc.UnixCCompiler()
    compiler_exe = ccompiler.compiler
    linker_exe = ccompiler.linker_exe


def get_config_var(name, default='', *, _get_config_var=sysconfig.get_config_vars().get):
    return _get_config_var(name, default)


INCDIR = sysconfig.get_path('include')
LIBDIR1 = get_config_var('LIBDIR')
LIBDIR2 = get_config_var('LIBPL')
PYLIB_DIR = get_config_var("installed_platbase")
PYLIB = get_config_var('LIBRARY')
PYLIB_DYN = get_config_var('LDLIBRARY') if sys.platform != 'darwin' else ''
if PYLIB_DYN == PYLIB:
    # no shared library
    PYLIB_DYN = ''
elif PYLIB_DYN:
    # 'lib(XYZ).so' -> XYZ
    PYLIB_DYN = os.path.splitext(PYLIB_DYN)[0]
    if PYLIB_DYN.startswith('lib'):
        PYLIB_DYN = PYLIB_DYN[3:]

CFLAGS = get_config_var('CFLAGS') + ' ' + os.environ.get('CFLAGS', '')

OBJ_EXT = ccompiler.obj_extension
EXE_EXT = get_config_var('EXE')


def compile(source_file):
    ccompiler.compile(
        sources=[source_file],
        include_dirs=[INCDIR],
        extra_postargs=CFLAGS.split(),
    )


def link_exe(objects, app_name):
    library_dirs = [
        libdir for libdir in
        [LIBDIR1, LIBDIR2, os.path.join(PYLIB_DIR, "libs")]
        if libdir and os.path.isdir(libdir)
    ]
    libraries = []
    if PYLIB_DYN:
        libraries.append(PYLIB_DYN)
    elif PYLIB:
        libraries.append(os.path.join(LIBDIR1, PYLIB))

    ccompiler.link(
        ccompiler.EXECUTABLE,
        objects,
        output_filename=app_name + EXE_EXT,
        libraries=libraries,
        library_dirs=library_dirs,
        runtime_library_dirs=[PYLIB_DIR],
    )


def main(args):
    app_name, *c_files = args
    c_base_names = [filename[:-2] for filename in c_files]

    print("CFLAGS:", CFLAGS)
    print(f"PYLIBS: {PYLIB!r} {PYLIB_DYN!r}")
    print(f"LINK: {LIBDIR1!r} {LIBDIR2!r}")
    print("LIBDIR1:", os.listdir(LIBDIR1))

    compile_commands = [filename+'.c' for filename in c_base_names]
    for command in compile_commands:
        print("CC:", command)

    with ThreadPoolExecutor() as pool:
        for _ in pool.map(compile, compile_commands):
            pass

    link_exe(
        [filename + OBJ_EXT for filename in c_base_names],
        app_name=app_name,
    )


if __name__ == '__main__':
    main(sys.argv[1:])


################### run.py ########################

import os
import sys
from subprocess import run
from sysconfig import get_config_var

EXE_EXT = get_config_var('EXE')
PYLIB_DIR = get_config_var("installed_platbase")

PATH = os.environ.get('PATH', '')
sep = os.pathsep
os.environ.update(PATH=f".{sep}{PYLIB_DIR}{sep}{PATH}")

result = run([os.path.abspath(sys.argv[1] + EXE_EXT)], capture_output=True)
assert b"DONE" in result.stdout
assert b"DONE 1 2" in result.stdout


################# main_module.pyx ####################

import embedded1
import embedded2

assert __name__ == '__main__'

assert embedded1.attr == '1', embedded1.attr
assert embedded2.attr == '2', embedded2.attr

print("DONE", embedded1.attr, embedded2.attr)


################# embedded1.pyx ####################

attr = '1'

################# embedded2.pyx ####################

attr = '2'
