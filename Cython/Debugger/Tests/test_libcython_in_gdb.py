"""
Tests that run inside GDB.

Note: debug information is already imported by the file generated by
Cython.Debugger.Cygdb.make_command_file()
"""

import sys

# First, fix gdb's python. Make sure to do this before importing modules
# that bind output streams as default parameters

# for some reason sys.argv is missing in gdb
sys.argv = ['gdb']

# Allow gdb to capture output, but have errors end up on stderr
# sys.stdout = sys.__stdout__
sys.stderr = sys.__stderr__

import os
import warnings
import unittest
import traceback
from test import test_support

import gdb

from Cython.Debugger import libcython

class DebugTestCase(unittest.TestCase):
    
    def __init__(self, name):
        super(DebugTestCase, self).__init__(name)
        self.cy = libcython.cy
        self.module = libcython.cy.cython_namespace['codefile']
        self.spam_func, self.spam_meth = libcython.cy.functions_by_name['spam']
        self.ham_func = libcython.cy.functions_by_qualified_name[
            'codefile.ham']
        self.eggs_func = libcython.cy.functions_by_qualified_name[
            'codefile.eggs']
    
    def read_var(self, varname):
        return gdb.parse_and_eval('$cy_cname("%s")' % varname)
    
    def local_info(self):
        return gdb.execute('info locals', to_string=True)
    
class TestDebugInformationClasses(DebugTestCase):
    
    
    def test_CythonModule(self):
        "test that debug information was parsed properly into data structures"
        self.assertEqual(self.module.name, 'codefile')
        global_vars = ('c_var', 'python_var', 'SomeClass', '__name__', 
                       '__builtins__', '__doc__', '__file__')
        assert set(global_vars).issubset(self.module.globals)
        
    def test_CythonVariable(self):
        module_globals = self.module.globals
        c_var = module_globals['c_var']
        python_var = module_globals['python_var']
        self.assertEqual(c_var.type, libcython.CObject)
        self.assertEqual(python_var.type, libcython.PythonObject)
        self.assertEqual(c_var.qualified_name, 'codefile.c_var')
    
    def test_CythonFunction(self):
        self.assertEqual(self.spam_func.qualified_name, 'codefile.spam')
        self.assertEqual(self.spam_meth.qualified_name, 
                         'codefile.SomeClass.spam')
        self.assertEqual(self.spam_func.module, self.module)
        
        assert self.eggs_func.pf_cname
        assert not self.ham_func.pf_cname
        assert not self.spam_func.pf_cname
        assert not self.spam_meth.pf_cname
        
        self.assertEqual(self.spam_func.type, libcython.CObject)
        self.assertEqual(self.ham_func.type, libcython.CObject)
        
        self.assertEqual(self.spam_func.arguments, ['a'])
        self.assertEqual(self.spam_func.step_into_functions, set(['puts']))
        
        self.assertEqual(self.spam_func.lineno, 8)
        self.assertEqual(sorted(self.spam_func.locals), list('abcd'))


class TestParameters(unittest.TestCase):
    
    def test_parameters(self):
        assert libcython.parameters.colorize_code
        gdb.execute('set cy_colorize_code off')
        assert not libcython.parameters.colorize_code


class TestBreak(DebugTestCase):

    def test_break(self):
        result = gdb.execute('cy break codefile.spam', to_string=True)
        assert self.spam_func.cname in result
        
        self.assertEqual(len(gdb.breakpoints()), 1)
        bp, = gdb.breakpoints()
        self.assertEqual(bp.type, gdb.BP_BREAKPOINT)
        self.assertEqual(bp.location, self.spam_func.cname)
        assert bp.enabled


class TestStep(DebugTestCase):
    
    def test_step(self):
        # Note: breakpoint for spam is still set
        gdb.execute('run')
        
        gdb.execute('cy step', to_string=True) # b = c = d = 0
        gdb.execute('cy step', to_string=True) # b = 1
        self.assertEqual(self.read_var('b'), 1, self.local_info())
        self.assertRaises(RuntimeError, self.read_var('b'))
        gdb.execute('cont')


class TestNext(DebugTestCase):
    
    def test_next(self):
        pass
    
def main():
    try:
        # unittest.main(module=__import__(__name__, fromlist=['']))
        try:
            gdb.lookup_type('PyModuleObject')
        except RuntimeError:
            msg = ("Unable to run tests, Python was not compiled with "
                   "debugging information. Either compile python with "
                   "-g or get a debug build (configure with --with-pydebug).")
            warnings.warn(msg)
        else:
            tests = (
                TestDebugInformationClasses,
                TestParameters,
                TestBreak,
                TestStep
            )
            # test_support.run_unittest(tests)
            test_loader = unittest.TestLoader()
            suite = unittest.TestSuite(
                [test_loader.loadTestsFromTestCase(cls) for cls in tests])
                
            unittest.TextTestRunner(verbosity=1).run(suite)
    except Exception:
        traceback.print_exc()
        os._exit(1)